from fastapi import FastAPI
from pydantic import BaseModel
# from enum import Enum
# from starlette.websockets import WebSocket
from starlette.middleware.cors import CORSMiddleware
from starlette.responses import Response
from starlette.websockets import WebSocket
import websockets
import asyncio
import signal
import json
# import subprocess
import os

BLUESKY_WEBSOCKET = os.environ.get('BLUESKY_SERVICE_WEBSOCKET_URI')
# This is the url to the websocket of the bluesky service, for
# example: ws://bluesky:8765  or  ws://localhost:8765
if BLUESKY_WEBSOCKET is None:
    raise AssertionError("Missing required environment variable (BLUESKY_SERVICE_WEBSOCKET_URI) pointing to the bluesky service's websocket")

OPENAPI_PREFIX = os.environ.get('OPENAPI_PREFIX', '')
# This is necessary because in deployment, there is a traefik reverse
# proxy that is rerouting requests to the path /bluesky/api to this
# service, but is also stripping that prefix out of the path so when
# this service gets a http request it doesn't see that they requested
# /bluesky/api/docs, it just sees that they requested /docs, and it
# responds normally, but because it believes it's accessible at /docs
# it encodes this into the javascript sent back to the client wherein
# there is a part that tries to fetch an openapi_spec.json type file
# that defines all the endpoints and is how the /docs UI is able to
# render the right information. But unfortunately from the clients point
# of view they are actually accessing this service not through SERVER/
# but SERVER/bluesky/api/ and the docs not through SERVER/docs but
# SERVER/bluesky/api/docs, so if the javascript they retrieve then tries
# to subsequently retrieve SERVER/openapi_spec.json instead of
# SERVER/bluesky/api/openapi_spec.json you can see that it's going to have
# trouble

# This prefix is to be used by the swagger documentation when it generates
# client side javascript, so that the client can formulate a request back to
# this service in order to retrieve the openapi spec json file that is needed
# to describe all the available endpoints when the client visits the /docs
# endpoint - This solves the issue of the openapi swagger plugin assuming
# that there is no url path prefixing or reverse proxy type stuff going on.
# (read https://github.com/apigee-127/swagger-tools/issues/342 for background)


HTTP_409_CONFLICT = 409
# RE = None  # the RunEngine object
# create an object to share data between coroutines,
# stackoverflow link explains the python code:
# https://stackoverflow.com/questions/19476816/creating-an-empty-object-in-python#19476841
state = type('', (), {})()

state.update_event_object = None  # a file-wide accessible reference to an
                                     # asyncio event object that coroutines
                                     # can use to wait() for an event of
                                     # interest.
state.update_event_params = None
state.update_event_type = None   # a file-wide accessible reference to
                                    # a label to be paired with any set()
                                    # action on the update_event_object to give
                                    # the coroutines that were waiting on that
                                    # some context to inform their actions.

state.event_loop = None

# initial state (this is the source of truth):
# following information is shared with frontends and clients
state.busy = False
state.result = None

# state.random_mode = "random"  # "random" or "sequential"
                                # informs whether the random_1 value in the
                                # state.data dict is generated by random
                                # or incremented. (could have been a bool
                                # but then there would have been no excuse
                                # to demonstrate enum custom types in
                                # accepted json document request bodies.)


def notify_coroutines(event_type):
    """This function is to simplify the process of notifying coroutines of some
    event they may be waiting on and helps this file adhere to the DRY
    principle.
    """
    state.update_event_type = event_type
    state.update_event_object.set()
    # Any coroutines await'ing this update_event_object are ran now.
    state.update_event_object.clear()


async def start_scan(scan_name):
    # uri = "ws://localhost:8765"  # this needs to change to bluesky
    async with websockets.connect(BLUESKY_WEBSOCKET) as websocket:
        payload = {"type": "start", "plan": scan_name}
        await websocket.send(json.dumps(payload))
        response = await websocket.recv()
        await websocket.close(reason="will create a new connection if I need to")
        return json.loads(response)  # todo: this is at risk if the response ISN"T valid json but since we also authored the code sending the response back chances are it will be fine
    return {'status': 'error', 'msg': 'something went wrong in the websocket call to the bluesky service'}


################################################################################
##################    Start of our FastAPI implementation:    ##################
app = FastAPI(openapi_prefix=OPENAPI_PREFIX)

# for cors:
origins = [
    "*",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# defining the schema of acceptable POST request bodies for the endpoint
# /startscan, this is where any sort of parameters would be taken in to manipulate
# the bluesky plan.
class ScanParams(BaseModel):
    param1: str
    # param2: int


################################################################################
##########################    FastAPI endpoints:    ############################

@app.get("/")
def root_endpoint_diagnostics():
    return {"Helical": "Scan", "About": "This is the backend for the frontend (BFF) for the helical scan demo - see the /docs endpoint", "busy scanning": state.busy}


@app.get("/testfakehelicalscan")
async def run_a_simulated_scan():
    # THE FAKE ONE!
    # establish a new websocket connection to the bluesky websocket server
    result = await start_scan("simulated")
    # send a websocket message to the bluesky websocket server
    # message: {'type': 'start', 'plan': 'simulated'}
    # receive response from websocket server, expecting either resp['success'] True or False and corresponding resp['status'] message/reason.
    # close the websocket connection
    # return corresponding result {'starting' | 'busy' } to the client
    return result


@app.get("/testhelicalscan")
async def run_the_real_helical_scan_in_the_lab():
    # establish a new websocket connection to the bluesky websocket server
    result = await start_scan("helical scan")
    # send a websocket message to the bluesky websocket server
    # message: {'type': 'start', 'plan': 'helical scan'}
    # receive response from websocket server, expecting either resp['success'] True or False and corresponding resp['status'] message/reason.
    # close the websocket connection
    # return corresponding result {'starting' | 'busy' } to the client
    return result


@app.post("/startscan")
def startscan(s_params: ScanParams, response: Response):
    print("Helical scan starting")
    print(s_params)
    if state.busy:
        response.status_code = HTTP_409_CONFLICT
        return {"sorry": "currently busy with a previous scan"}
    state.busy = True
    notify_coroutines("busy")
    state.result = None
    state.update_event_params = s_params
    notify_coroutines("start_scan")
    # do_scan(RE)
    return {"confirm": "scan starting, currently ignoring your params though"}


@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    # Send an initial message to indicate what mode of 'busy' the state is in:
    await websocket.send_json({'busy': state.busy})
    # then just continually wait till another coroutine (like ..) set()'s the
    # state.update_event_object:
    while True:
        await state.update_event_object.wait()
        if state.update_event_type == "busy":
            await websocket.send_json({'busy': state.busy})
        if state.update_event_type == "shutdown":
            break

    await websocket.close()


################################################################################
#######    background task to run concurrently with fastapi server    ##########


async def background_task():
    print("background task starting")
    while True:
        await state.update_event_object.wait()
        if state.update_event_type == "start_scan":
            # loop = asyncio.get_event_loop()
            # grab the event loop from the reference stored in our 'state' object in attempt to fix
            # "There is no current event loop in thread" issue we're seeing in prod
            # https://stackoverflow.com/questions/46727787/runtimeerror-there-is-no-current-event-loop-in-thread-in-async-apscheduler#56580615

            # state.result = await state.event_loop.run_in_executor(None, do_scan, state.event_loop)


            #
            """this didn't work as expected but did produce a helpful error message"""
            # def worker():
            #     do_scan()
            #
            # thread = Thread(target=worker, args=())
            # thread.daemon = False
            # thread.start()
            #
            """try with subprocess instead"""
            # subprocess.call(['python3', '/bluesky/bluesky_plan.py'])  # this line is tested and works, but blocks!
            # subprocess.check_output('python /home/alex/apps/bright-sac-2019/bluesky-library/subprocesstest.py', shell=True)
            """try with os.spawn"""
            # WARNING THIS IS VERY BAD CODE BUT ITS THE FIRST EXAMPLE THAT WORKS FROM
            # THE PRESS OF THE BUTTON ON THE WEB GUI
            C = ['python3', '/bluesky/bluesky_plan.py'] # THIS PATH IS SPECIFIC TO THE CONTAINER
            os.spawnvpe(os.P_NOWAIT, 'python3', C, os.environ)
            # state.busy = False
            # notify_coroutines("busy")


################################################################################
################    fastapi startup and shutdown routines    ###################


def exit_gracefully(*args, **kwargs):
    notify_coroutines('shutdown')


@app.on_event("startup")
async def service_startup():
    # catch Ctrl+C inform websocket to leave loop in order to trigger fastapi shutdown
    signal.signal(signal.SIGINT, exit_gracefully)
    signal.signal(signal.SIGTERM, exit_gracefully)
    # establish a run engine
    from bluesky import RunEngine
    RE = RunEngine()


# store a reference to the running event loop in the state object so that we
# can refer to it later, I didn't think this would be necessary but tried
# this in an attempt to fix a "There is no current event loop in thread" problem
state.event_loop = asyncio.get_event_loop()

# initialise the event_object used between coroutines to signal events:
state.update_event_object = asyncio.Event(loop=asyncio.get_event_loop())

# Start the background task and store the asyncio TASK object in a
# task variable so as to capture any returned results or exceptions
# to make use of such result would mean you would have to 'await'
# the task variable. Admittedly this is a hacky attempt at fixing
# https://stackoverflow.com/questions/46890646/asyncio-weirdness-of-task-exception-was-never-retrieved
task = asyncio.ensure_future(background_task())
# Link to the code used as inspiration for this trick (I didn't know you
# could just do .create_task (or ensure_future in python 3.6), I thought
# you would need to get a hold of
# the event loop or something and use something like .gather or something!
# https://github.com/tiangolo/fastapi/issues/617
# The `@app.on_event("startup")` decorator was inappropriate for starting
# our simulate_data_gathering coroutine because the actual fastAPI server
# will not start until this is complete, but `while True` loop ensures it
# never completes.
